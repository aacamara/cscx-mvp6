name: Risk Policy Gate

on:
  pull_request:
    types: [opened, synchronize, reopened]
    branches: [main]

permissions:
  contents: read
  pull-requests: write
  checks: write

jobs:
  policy-gate:
    name: Risk Classification & Policy Check
    runs-on: ubuntu-latest
    outputs:
      tier: ${{ steps.classify.outputs.tier }}
      require_human: ${{ steps.classify.outputs.require_human }}
      require_playwright: ${{ steps.classify.outputs.require_playwright }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install minimatch
        run: npm install minimatch@9

      - name: Get changed files
        id: changed
        uses: tj-actions/changed-files@v44
        with:
          json: true

      - name: Classify risk tier
        id: classify
        uses: actions/github-script@v8
        with:
          script: |
            const fs = require('fs');
            const { minimatch } = require('${{ github.workspace }}/node_modules/minimatch');

            const policy = JSON.parse(
              fs.readFileSync('.github/risk-policy.json', 'utf8')
            );

            let changedFiles;
            try {
              changedFiles = JSON.parse(`${{ steps.changed.outputs.all_changed_files }}`);
            } catch {
              changedFiles = [];
            }

            if (changedFiles.length === 0) {
              core.setOutput('tier', 'low');
              core.setOutput('require_human', 'false');
              core.setOutput('require_playwright', 'false');
              console.log('No changed files detected. Defaulting to low tier.');
              return;
            }

            const tierOrder = ['low', 'high', 'critical'];
            let maxTier = 'low';
            let matchedFiles = {};

            for (const file of changedFiles) {
              let fileTier = policy.defaults.unmatched_tier;

              for (const tierName of tierOrder) {
                const tierDef = policy.tiers[tierName];
                if (!tierDef) continue;
                for (const pattern of tierDef.paths) {
                  if (minimatch(file, pattern, { dot: true })) {
                    if (tierOrder.indexOf(tierName) > tierOrder.indexOf(fileTier)) {
                      fileTier = tierName;
                    }
                  }
                }
              }

              if (!matchedFiles[fileTier]) matchedFiles[fileTier] = [];
              matchedFiles[fileTier].push(file);

              if (tierOrder.indexOf(fileTier) > tierOrder.indexOf(maxTier)) {
                maxTier = fileTier;
              }
            }

            const tierDef = policy.tiers[maxTier] || { require: policy.defaults.require };
            const req = tierDef.require || policy.defaults.require;

            core.setOutput('tier', maxTier);
            core.setOutput('require_human', String(req.human_approval || false));
            core.setOutput('require_playwright', String(req.playwright_evidence || false));

            console.log(`PR classified as: ${maxTier}`);
            console.log('File breakdown:');
            for (const [tier, files] of Object.entries(matchedFiles)) {
              console.log(`  ${tier}: ${files.length} file(s)`);
              for (const f of files) console.log(`    - ${f}`);
            }

      - name: Apply risk labels
        uses: actions/github-script@v8
        with:
          script: |
            const tier = '${{ steps.classify.outputs.tier }}';
            const prNumber = context.payload.pull_request.number;
            const riskLabels = ['risk:critical', 'risk:high', 'risk:low'];
            const targetLabel = `risk:${tier}`;

            // Get existing labels
            const { data: existingLabels } = await github.rest.issues.listLabelsOnIssue({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
            });

            // Remove old risk labels
            for (const label of existingLabels) {
              if (riskLabels.includes(label.name) && label.name !== targetLabel) {
                await github.rest.issues.removeLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  name: label.name,
                }).catch(() => {});
              }
            }

            // Ensure target label exists, create if not
            try {
              await github.rest.issues.getLabel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                name: targetLabel,
              });
            } catch {
              const colors = { 'risk:critical': 'd73a49', 'risk:high': 'e36209', 'risk:low': '28a745' };
              await github.rest.issues.createLabel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                name: targetLabel,
                color: colors[targetLabel] || 'ededed',
                description: `Risk tier: ${tier}`,
              });
            }

            // Apply label
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              labels: [targetLabel],
            });

      - name: Post classification comment
        uses: actions/github-script@v8
        with:
          script: |
            const tier = '${{ steps.classify.outputs.tier }}';
            const sha = context.payload.pull_request.head.sha.substring(0, 7);
            const requireHuman = '${{ steps.classify.outputs.require_human }}';
            const requirePlaywright = '${{ steps.classify.outputs.require_playwright }}';
            const icon = { critical: 'ðŸ”´', high: 'ðŸŸ¡', low: 'ðŸŸ¢' }[tier] || 'âšª';

            const marker = '<!-- risk-policy-gate -->';
            const body = `${marker}
            ## ${icon} Risk Classification: \`${tier}\`

            | Check | Required |
            |-------|----------|
            | CodeRabbit Review | Yes |
            | Human Approval | ${requireHuman} |
            | Delta TS Clean | Yes |
            | Playwright Evidence | ${requirePlaywright} |
            | Tests Pass | Yes |

            > Evaluated at commit \`${sha}\` â€” re-evaluates on every push.

            ---
            _Risk Policy Gate v1.0 Â· [How We Build](docs/HOW_WE_BUILD.md)_`;

            const prNumber = context.payload.pull_request.number;
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
            });

            const existing = comments.find(c => c.body && c.body.includes(marker));

            if (existing) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existing.id,
                body,
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body,
              });
            }
